# DocFlow Cloud Workflow Rules

> Version: 3.0.0
> This file is synced from the DocFlow source repo. Run `/docflow-update` to check for updates.

## Overview

DocFlow Cloud is a hybrid spec-driven workflow:
- **Workflow state (specs)** → Lives in Linear
- **Understanding (context/knowledge)** → Lives locally in git
- **System rules (this file)** → Local, synced from central repo

---

## Context Loading Strategy

### On Every Interaction
1. **Check Linear** for "In Progress" issues (know current state)
2. **Scan Linear** for "Blocked" issues (may need attention)
3. **Scan Linear** for issues needing review (status=REVIEW)
4. **Scan Linear** for issues ready for QE (status=QA)

### When Starting/Planning New Work
**Load these to understand scope:**
- `docflow/context/overview.md` (project vision)
- Query Linear for backlog issues
- Load active issue being planned

### When Implementing
**Load these for execution context:**
- Current Linear issue (full description + comments)
- `docflow/context/stack.md` (technical patterns)
- `docflow/context/standards.md` (code conventions)
- If issue has Figma attachment → call Figma MCP for design context

**Remember: Implementation = Code + Tests + Docs**
- Write tests alongside code
- Document significant decisions to knowledge base
- Update context files if architecture changes

### When Reviewing (status=REVIEW)
**Load these for quality assessment:**
- Linear issue being reviewed
- `docflow/context/standards.md` (code checklist)
- Implementation comments from Linear

### When Searching for Existing Code
- Use `codebase_search` to find patterns
- Use `grep` to find exact code
- Check `docflow/knowledge/` if search reveals relevant docs

### Knowledge Base (`docflow/knowledge/`)
- Scan `INDEX.md` first (provides overview)
- Load selectively based on task
- Never auto-load everything

---

## Status States

### Full Workflow (Features & Bugs)
```
BACKLOG → READY → IMPLEMENTING ──→ REVIEW → TESTING → COMPLETE
   │         │          │            │         │         │
 Linear   Linear     Linear       Linear    Linear    Linear
Backlog    Todo    In Progress  In Review    QA       Done
                        │            │
                        ▼            │
                    BLOCKED ◄────────┘
                        │
                      Linear
                     Blocked
                        │
                        └──→ (back to IMPLEMENTING when unblocked)
```

**What each state means:**

| State | Linear | What Happens |
|-------|--------|--------------|
| BACKLOG | Backlog | Raw ideas or refined specs awaiting prioritization |
| READY | Todo | Refined, prioritized, ready to pick up |
| IMPLEMENTING | In Progress | Code + Tests + Docs being written |
| BLOCKED | Blocked | Stuck - needs feedback, dependency, or decision |
| REVIEW | In Review | Implementation complete, awaiting code review (agentic or human) |
| TESTING | QA | Code review passed, manual testing by user |
| COMPLETE | Done | Verified and shipped |

**Terminal States (via `/close`):**

| State | Linear | What Happens |
|-------|--------|--------------|
| ARCHIVED | Archived | Deferred to future - not canceled, just not now |
| CANCELED | Canceled | Decision made not to pursue |
| DUPLICATE | Duplicate | Already exists - link to original issue |

### Intake/Triage Flow
```
Quick Capture (with `triage` label)
        │
        │ /refine (triage path)
        ▼
    BACKLOG (typed, templated)
        │
        │ /refine (refinement path)
        ▼
      READY
```

**Triage label:** Issues with `triage` label are raw captures needing classification and structure.

### Simplified Workflow (Chores & Ideas)
```
BACKLOG → ACTIVE → COMPLETE
   │         │         │
 Linear   Linear    Linear
Backlog In Progress  Done
```

---

## Agent Responsibilities

### PM/Planning Agent

**When Creating Specs (from IDE via /capture):**
1. Create Linear issue with appropriate template
2. Set type label (feature, bug, chore, idea)
3. Set priority (1-4) based on urgency
4. Set estimate (1-5) based on complexity
5. Set milestone (optional - use default from config or user override)
6. Add Figma attachments if design exists
7. Leave in Backlog state
8. Add comment: `**Created** — [Brief context].`

**When Triaging (issues with `triage` label via /refine):**
1. Find issues with `triage` label
2. Analyze raw content
3. Suggest type classification (feature/bug/chore/idea)
4. Apply appropriate template structure
5. Remove `triage` label, add type label
6. Add comment: `**Triaged** — Classified as [type], template applied.`

**When Refining (templated backlog items via /refine):**
1. Load issue + overview.md + knowledge INDEX
2. Assess completeness (context, user story, acceptance criteria)
3. Identify gaps and improvements
4. Refine acceptance criteria, add technical notes
5. Set complexity estimate if not set
6. Add comment: `**Refined** — [What was improved]. Ready for activation.`

**When Activating Work:**
1. Get developer username (git config)
2. **Check if already assigned** - warn if assigned to someone else (prevent race conditions)
3. Set priority if not already set (ask or infer)
4. Set estimate if not already set (ask or infer)
5. Assign Linear issue to developer
6. Move to "In Progress" state
7. Add comment: `**Activated** — Assigned to [name], Priority: [P], Estimate: [E].`

**When Reviewing Code (status=REVIEW via /review):**
1. Check Linear for issues in "In Review" state
2. Read issue description + all implementation comments
3. Load `docflow/context/standards.md`
4. **Analyze actual code changes:**
   - Read changed files (from completion comment)
   - Check against standards.md conventions
   - Look for obvious issues or anti-patterns
   - Verify error handling is appropriate
5. **Verify acceptance criteria:**
   - All functionality criteria checked in code
   - Tests written and cover requirements
   - Documentation updated (or N/A appropriate)
6. **Make decision:**
   - If approved:
     - Move to "QA" state
     - Add comment: "✅ Code review passed. [Summary of what was verified]"
   - If issues found:
     - Move back to "In Progress"
     - Add comment with specific issues to address

**When Closing (after QE approval):**
1. Move to "Done" state
2. Add comment: "✅ Completed and verified"

### Implementation Agent

**On Startup:**
1. Query Linear for issues assigned to current user in "Todo" or "In Progress"
2. **Check assignment before starting** - warn if picking up issue assigned to someone else
3. If multiple, ask user which to work on
4. Read full issue including comments
5. Show implementation checklist reminder (code + tests + docs)

**During Implementation:**
1. Write tests alongside code (not after)
2. Update description checkboxes as criteria are completed
3. Add progress comments: `**Progress** — What was done.`
4. Document decisions in comments (dated)
5. If Figma attached: call Figma MCP for design specs
6. Document significant patterns/decisions to knowledge base (see Documentation Rules below)

**On Completion:**
1. Verify ALL acceptance criteria checkboxes are checked:
   - Functionality criteria
   - Tests criteria (or marked N/A)
   - Documentation criteria (or marked N/A)
2. Move to "In Review" state
3. Add detailed comment:
   ```markdown
   **Ready for Review** —
   
   **Summary:** [What was built/fixed]
   **Files Changed:** [count]
   **Tests:** [what was tested]
   **Documentation:** [docs added/updated or N/A]
   ```

**On Blocker:**
1. Move to "Blocked" state
2. If blocked by another issue, create dependency link (blockedByIssueIds)
3. Add comment: `**Blocked** — [What's blocking]. Needs: [what's needed]. Blocked by: LIN-XXX (if applicable).`
4. Tag PM/reviewer if needed

**Resuming from Blocked:**
- When blocker is resolved, `/implement` moves issue back to "In Progress"
- Add comment: `**Unblocked** — [What resolved the blocker].`

### QE/Validation Agent

**When Testing:**
1. Query Linear for issues in "QA" state
2. Guide user through testing acceptance criteria
3. Document test results in comments

**When User Approves:**
- Recognize approval phrases: "looks good", "approve", "ship it", "QE passed"
- Add approval comment
- Signal ready for PM to close

**When User Reports Issues:**
- Document issues in comment
- Move back to "In Progress"
- Add comment with specific bugs found

---

## Linear Integration

### Reading from Linear
```
Use Linear MCP to:
- Query issues by status, assignee, labels
- Read issue details including comments
- Get attachment URLs (Figma links, screenshots)
```

### Writing to Linear
```
Use Linear MCP to:
- Create new issues
- Update issue status, priority, estimate
- Update issue description (including checkboxes)
- Add comments
- Assign users
```

### Priority Values
| Value | Name    | Use When                          |
|-------|---------|-----------------------------------|
| 0     | None    | Not yet triaged                   |
| 1     | Urgent  | Drop everything, fix now          |
| 2     | High    | Next up, important                |
| 3     | Medium  | Normal priority (default)         |
| 4     | Low     | Nice to have, when time permits   |

### Estimate Values (Complexity)
| Value | Name | Rough Effort         |
|-------|------|----------------------|
| 1     | XS   | < 1 hour             |
| 2     | S    | 1-4 hours            |
| 3     | M    | Half day to full day |
| 4     | L    | 2-3 days             |
| 5     | XL   | Week+                |

### Acceptance Criteria as Checkboxes
Issue descriptions contain acceptance criteria as markdown checkboxes:
```markdown
## Acceptance Criteria
- [ ] First criterion
- [ ] Second criterion
- [x] Completed criterion
```

**During implementation:**
1. Read current description to see checkbox state
2. As each criterion is completed, update description with `[x]`
3. Use `update_issue` with full updated description
4. Add comment noting progress

**This keeps the issue as the single source of truth.**

### Comment Format
Use consistent comment format for audit trail:
```markdown
**Status** — Brief description of action taken.
```

Examples:
- `**Activated** — Assigned to Matt, Priority: High, Estimate: S.`
- `**Progress** — Completed data model, starting on hooks.`
- `**Blocked** — Waiting on API access from backend team. Needs: Backend team to provision credentials.`
- `**Unblocked** — API access granted, resuming implementation.`
- `**Complete** — All acceptance criteria met.`

### Team Collaboration

**Assignment:**
Assign issues to team members by name, email, or "me":
```typescript
// Via MCP
updateIssue(issueId, { assignee: "cory" })      // by name
updateIssue(issueId, { assignee: "me" })        // self
updateIssue(issueId, { assignee: "cory@..." })  // by email
```

**Subscribers (Notifications):**
Add subscribers to notify team members of all issue updates:
```bash
# Via GraphQL API (requires LINEAR_API_KEY)
issueUpdate(id: "...", input: { subscriberIds: ["user-id-1", "user-id-2"] })
```

**Finding Users:**
```typescript
// Via MCP
list_users({ query: "cory" })  // Find user by name/email
```

**When to use each:**
- **Assignment** → Ownership (who's responsible)
- **Subscribers** → Notifications (who should know about updates)

### Figma Integration
```
When issue has Figma attachment:
1. Extract fileKey and nodeId from URL
2. Call Figma MCP: get_design_context(fileKey, nodeId)
3. Use returned specs for implementation
```

### Configuration
```
Read .docflow.json for:
- teamId (required)
- projectId (required for project-scoped work)
- defaultMilestoneId (optional - auto-assign new issues to this milestone)
- label IDs for spec types
- state IDs for status mapping
```

### Milestones (Optional)
```
Milestones organize work by release, quarter, or target date.

When creating issues:
- If defaultMilestoneId is set in config → use it
- If user specifies milestone → override default
- If no milestone configured → leave blank (null)

Query milestones:
  linear_getProjectMilestones({ projectId })

Assign milestone:
  createIssue({ ..., projectMilestoneId: milestoneId })
```

### Environment Variables
```
Set in project .env file:

LINEAR_API_KEY=lin_api_xxxxx

Get key from: Linear → Settings → API → Personal API keys
Required for: Project updates (GraphQL API)

Load with: source .env
```

---

## Commands

### PM/Planning Commands

**`/start-session`**
1. Query Linear for current user's issues
2. Show: QA issues, Review issues, Blocked issues, In Progress issues, Ready issues
3. Show: Stale issues (in active state too long without activity)
4. Show: Dependency issues (blocked by incomplete work)
5. Show: Triage queue (issues with `triage` label)
6. Ask what to work on

**`/wrap-session`**
1. Summarize what was accomplished
2. Update any in-progress Linear issues
3. Offer to post project update (health + summary)
4. Note what's next

**`/project-update [project]`**
1. Compose update summary
2. Set health status (onTrack, atRisk, offTrack)
3. Post via Linear GraphQL API (requires LINEAR_API_KEY)
4. Confirm with link

**`/sync-project`**
1. Read docflow/context/ files (overview, stack, standards)
2. Generate short summary (255 char) + full content
3. Update Linear project (description + content fields)
4. Confirm sync complete

**`/capture`**
1. Ask for type: feature, bug, chore, idea
2. Gather title, description, context
3. Create Linear issue with template
4. Set to Backlog

**`/refine [issue]`** ← Combined triage + refinement
1. Query Linear for issue (or show triage/refinement queues)
2. **If `triage` label or missing structure:**
   - Classify type (feature/bug/chore/idea)
   - Apply template structure
   - Remove `triage` label, add type label
3. **If templated:**
   - Assess completeness
   - Refine acceptance criteria, technical notes
   - Prepare for activation

**`/activate [issue]`**
1. Get assignee (current user or specified)
2. Assign issue
3. Move to Todo state

**`/close [issue]`**
1. Determine terminal state (default: Done)
2. For Done: verify QA approval
3. Move to terminal state (Done/Archived/Canceled/Duplicate)
4. Add appropriate comment

### Implementation Commands

**`/implement [issue]`**
1. Query Linear for issue
2. Load into context + show implementation checklist
3. Read Figma if attached
4. Move to In Progress
5. Begin implementation (code + tests + docs)

**`/block`**
1. Move issue to "Blocked" state
2. Link blocking issue (if dependency blocker)
3. Add blocker comment with details + issue link
4. Tag relevant people

**`/attach [file] [issue]`**
1. Determine method (GitHub link or direct upload)
2. For committed files: create GitHub link attachment
3. For local files: upload to Linear storage, create attachment
4. Confirm with link

### Review Commands

**`/review [issue]`** ← Code review only (post-implementation)
1. Query Linear for issues in "In Review" state
2. Load implementation details + standards.md
3. Analyze code changes, verify tests/docs
4. Approve → QA, or Request changes → In Progress

### QE Commands

**`/validate [issue]`**
1. Query Linear for issue in QA state
2. Show acceptance criteria
3. Guide user through testing

### System Commands

**`/status`**
1. Query Linear for current state
2. Show active work, blocked items, what's ready
3. Show stale issues (extended time in active state)
4. Show dependency issues (blocked by incomplete work)
5. Show triage queue count

**`/docflow-update`**
1. Check source repo for updates
2. Show changelog if available
3. Sync rules if user approves

---

## Natural Language Triggers

### Start Session
"let's start" / "what's next" / "where are we" → `/start-session`

### Wrap Session
"wrap it up" / "I'm done" / "save progress" → `/wrap-session`

### Capture
"capture that" / "add to backlog" / "found a bug" / "new idea" → `/capture`

### Refine (Triage + Spec Refinement)
"refine [issue]" / "triage [issue]" → `/refine`
"what needs triage" / "triage queue" → Show triage queue
"prepare [issue]" / "get [issue] ready" → `/refine`
"clean up backlog" → Show triage + refinement queues

### Implement
"let's build" / "implement this" / "start working" → `/implement`

### Review (Code Review Only)
"review [issue]" (when in Review state) → `/review`
"code review" / "check the implementation" → `/review`
"what needs code review" → Show review queue

### Attach
"attach [file]" / "link the doc" / "upload notes" → `/attach`

### Validate
"test this" / "QE test" / "manual testing" → `/validate`

### QE Approval
"looks good" / "approve" / "ship it" / "QE passed" → Mark approved

### Close (Terminal States)
"close [issue]" / "mark complete" / "this is done" → `/close` (Done)
"archive [issue]" / "defer [issue]" / "put on hold" → `/close` (Archived)
"cancel [issue]" / "won't do" / "kill [issue]" → `/close` (Canceled)
"duplicate of LIN-XXX" / "same as LIN-XXX" → `/close` (Duplicate)

### Project Update
"post project update" / "update project status" → `/project-update`

### Sync Project
"sync project" / "update project description" → `/sync-project`

### Save Link
"save this link" / "add to links" / "remember this link" → Add to overview.md Links + offer sync

### Status
"what's the status" / "where are we" → `/status`

---

## Critical Rules

### Never Create Local Spec Files
- ❌ NO files in docflow/specs/ (directory doesn't exist)
- ❌ NO INDEX.md or ACTIVE.md files
- ✅ ALL specs live in Linear as issues

### Context Stays Local
- ✅ docflow/context/ always in git
- ✅ docflow/knowledge/ always in git
- These are version-controlled with code

### Update Linear, Not Local Files
- Status changes → Update Linear issue state
- Progress notes → Add Linear comment
- Decisions → Add dated Linear comment (format: `### YYYY-MM-DD - Decision Title`)
- Blockers → Add Linear comment and tag

### Document in Linear Comments
Format for implementation notes:
```markdown
### YYYY-MM-DD - Implementation Progress

**Files Changed:**
- `path/to/file.tsx` - Added component

**Decisions:**
- Used pattern X because Y

**Next Steps:**
- [ ] Remaining work
```

### Search Before Creating
- Use codebase_search to find existing code
- Check docflow/knowledge/ for existing patterns
- Avoid duplicating functionality

---

## Documentation Rules

### When to Document (Significant Changes Only)

Documentation is required when changes are **significant**. Mark documentation criteria as N/A if no significant documentation is needed.

**Document in `docflow/knowledge/` when:**
- **decisions/** - Architectural or significant technical decisions
  - Choosing between approaches (e.g., "Why we use X over Y")
  - Trade-offs made and rationale
- **notes/** - Gotchas, learnings, non-obvious solutions
  - Things that would trip up future developers
  - Workarounds for library/framework issues
- **features/** - Complex feature explanations
  - Multi-component features that need overview
  - Non-obvious data flows or interactions

**Update `docflow/context/` when:**
- `stack.md` - Adding new technology, changing patterns
- `standards.md` - New conventions, updated guidelines
- `overview.md` - Scope changes, new links

### Auto-Update Knowledge INDEX

When adding new documentation to `docflow/knowledge/`:
1. Add entry to `docflow/knowledge/INDEX.md`
2. Include: file path, title, brief description, date added

**INDEX.md entry format:**
```markdown
| [Title](path/to/file.md) | Brief description | YYYY-MM-DD |
```

### Documentation Comment Format

When documentation is added during implementation, add a Linear comment:

```markdown
**Documentation Updated** —
- Added: `docflow/knowledge/decisions/adr-[name].md` - [Brief description]
- Updated: `docflow/context/stack.md` - [What changed]

[Links available in repo after merge]
```

### What NOT to Document

Don't create documentation for:
- Trivial changes (rename, small refactor)
- Standard patterns already in standards.md
- Temporary solutions being replaced soon
- Information already in the spec/issue

**Git history + spec details + significant docs = complete history**

### Capture Useful Links
When the user shares or mentions a useful link during conversation:
- **GitHub repos** (their own or dependencies)
- **Figma files** or design links
- **Documentation** (APIs, libraries, guides)
- **Dashboards** (deployment, analytics, services)
- **External services** (APIs, third-party tools)

**Prompt the user:**
```
I noticed you shared [link]. Would you like me to save this to your project's Related Links?

This will:
1. Add it to docflow/context/overview.md
2. Sync to your Linear project description (via /sync-project)

Save this link? (yes/no)
```

**If yes:**
1. Add to the Links section in `docflow/context/overview.md`
2. Use format: `- [Link name](URL) - Brief description`
3. Ask for a brief description if not obvious
4. Offer to run `/sync-project` to update Linear

**Don't prompt for:**
- Temporary links (localhost, preview URLs)
- Links already in the project
- Links shared just for reference in conversation

---

## Provider Abstraction

This workflow is designed to work with multiple PM tools. Linear is the first provider.

### What's Provider-Specific
- Issue creation/updates (via MCP)
- Status state names
- Label/tag system
- Comment format

### What's Provider-Agnostic
- Workflow stages (BACKLOG → COMPLETE, including BLOCKED)
- Agent roles and responsibilities
- Context loading strategy
- Local file structure

### Switching Providers
1. Update `.docflow.json` with new provider config
2. Update `.cursor/mcp.json` with new provider MCP
3. Workflow commands stay the same

---

*End of DocFlow Cloud Rules*
